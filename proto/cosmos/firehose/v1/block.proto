syntax = "proto3";
package cosmos.firehose.v1;
option go_package = "github.com/cosmos/cosmos-sdk/store/streaming/firehose";

import "google/protobuf/timestamp.proto";
import "cosmos/base/tendermint/v1beta1/types.proto";
import "tendermint/abci/types.proto";
import "tendermint/types/params.proto";
import "gogoproto/gogo.proto";

message Block {
  cosmos.base.tendermint.v1beta1.Header header = 1;
  RequestFinalizeBlock req = 2;
  ResponseFinalizeBlock res = 3;
  reserved 4; //repeated StoreKVPair changeSet = 4;
}

message RequestFinalizeBlock {
  repeated bytes       txs = 1;
  tendermint.abci.CommitInfo           decided_last_commit = 2 [(gogoproto.nullable) = false];
  repeated tendermint.abci.Misbehavior misbehavior = 3 [(gogoproto.nullable) = false];
  // hash is the merkle root hash of the fields of the decided block.
  bytes                     hash = 4;
  int64                     height = 5;
  google.protobuf.Timestamp time = 6 [(gogoproto.nullable) = false, (gogoproto.stdtime) = true];
  bytes                     next_validators_hash = 7;
  // proposer_address is the address of the public key of the original proposer of the block.
  bytes proposer_address = 8;
}

message ResponseFinalizeBlock {
  // set of block events emmitted as part of executing the block
  repeated tendermint.abci.Event events = 1
  [(gogoproto.nullable) = false, (gogoproto.jsontag) = "events,omitempty"];
  // the result of executing each transaction including the events
  // the particular transction emitted. This should match the order
  // of the transactions delivered in the block itself
  repeated ExecTxResult tx_results = 2;
  // a list of updates to the validator set. These will reflect the validator set at current height + 2.
  repeated tendermint.abci.ValidatorUpdate validator_updates = 3 [(gogoproto.nullable) = false];
  // updates to the consensus params, if any.
  tendermint.types.ConsensusParams consensus_param_updates = 4;
  // app_hash is the hash of the applications' state which is used to confirm that execution of the transactions was deterministic. It is up to the application to decide which algorithm to use.
  bytes app_hash = 5;
}

message ExecTxResult {
  uint32         code = 1;
  bytes          data = 2;
  string         log = 3;  // nondeterministic
  string         info = 4;  // nondeterministic
  int64          gas_wanted = 5 [json_name = "gas_wanted"];
  int64          gas_used = 6 [json_name = "gas_used"];
  repeated tendermint.abci.Event events = 7
  [(gogoproto.nullable) = false, (gogoproto.jsontag) = "events,omitempty"];  // nondeterministic
  string codespace = 8;
}